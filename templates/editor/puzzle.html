{% extends 'base.html' %}
{% load static %}
{% block meta %}
<script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>
<script src="https://cdn.jsdelivr.net/npm/js-cookie@rc/dist/js.cookie.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/chart.js@2.9.3/dist/Chart.min.js"></script>
<script src="https://unpkg.com/vue-chartjs/dist/vue-chartjs.min.js"></script>
<link rel="stylesheet" href="https://unpkg.com/vue-nav-tabs/themes/vue-tabs.css">
<script src="https://unpkg.com/vue-nav-tabs/dist/vue-tabs.js"></script>
{% endblock meta %}

{% block content %}



<div id="editor-app">

  {% block topbar %}
  <header>
    <nav class="navbar-top">
      <div class="left-nav">
        <a class="logo" href="{% url 'home' %}">
          <h1>WordNerd</h1>
        </a>
        <div v-if="!completed" class="save-container">
          <button class="btn save-btn" @click="savePuzzle">Save</button>
          <div class="last-saved-container">
            <p v-show="lastSaved">Last saved at ${ lastSaved.time }</p>
            <p v-show="lastSaved">on ${ lastSaved.date }</p>
          </div>
        </div>
      </div>
      <ul class="nav-top-links">
        <a href="{% url 'auth_logout' %}?next=/">Logout </a>
      </ul>
    </nav>
  </header>
  {% endblock topbar %}


  {% block main %}
  <vue-tabs>
    <v-tab title="Grid">
      <div class="input-container">
        <span v-if="grid[activeCell]===BLACK" style="visibility:hidden; height:1.4rem"><b>Hide</b></span>
        <span class="clue-input-label" v-if="grid[activeCell]!==BLACK">
          ${ gridnums[highlighted[0]] } ${ direction }:
        </span>
        <div class="clue-input-container">
          <textarea id="clue-input" wrap="soft" maxlength="200" style="overflow:auto; resize:none;"
            v-model.trim="currentClue" :disabled="completed"></textarea>
        </div>

        <div class="grid-container" tabindex="0">
          <div class='grid' :style="gridStyle">
            <x-cell v-for="n in length" :key="n" :idx="n-1" :active-cell="activeCell" :input-area="inputArea"
              :grid="grid" :highlighted="highlighted" :col-n="colN" :row-n="rowN" :circles="circles"
              @cell-clicked="handleCellClick">
              <div slot="number" class="number" :style="numberStyle">
                <span v-if="gridnums[n-1] !== 0">${ gridnums[n-1] }</span>
              </div>
              <div slot="entry" class="entry" :style="entryStyle">
                ${ grid[n-1][0] }
              </div>
            </x-cell>
          </div>
        </div>
      </div>


      <div class="clue-list-container">
        <div class="clue-list">
          <p class="clue-list-title">Across:</p>
          <ul>
            <x-clue v-for="number in clueNumbers.across" :key="number" :direction="direction" :gridnums="gridnums"
              :highlighted="highlighted" :clue-type="across" :number="number" :cross-numbers="getNumberInterval(across)"
              @clue-clicked="handleClueClick">
              <span class="clue-number">${ number }:</span> ${ clues.across[String(number)] }
            </x-clue>
          </ul>
        </div>
        <div class="clue-list">
          <p class="clue-list-title">Down:</p>
          <ul>
            <x-clue v-for="number in clueNumbers.down" :key="number" :direction="direction" :gridnums="gridnums"
              :highlighted="highlighted" :clue-type="down" :number="number" :cross-numbers="getNumberInterval(down)"
              @clue-clicked="handleClueClick">
              <span class="clue-number">${ number }:</span> ${ clues.down[String(number)] }
            </x-clue>
          </ul>
        </div>
      </div>
    </v-tab>

    <v-tab title="Puzzle Properties">
      <div class="properties-container">
        <div class="title-container prop-container">
          <label for="title-inp">Title:</label>
          <input v-model.trim="title" type="text" id="title-inp" class="prop-inp" maxlength="64" :disabled="completed">
        </div>
        <div class="description-container prop-container">
          <label for="description-inp">Description/Notes:</label>
          <textarea v-model.trim="description" id="description-inp" maxlength="1023" :disabled="completed"></textarea>
        </div>
        <div class="prop-container">
          <label for="author-inp">Author(s) can be recorded here:</label>
          <input v-model="author" type="text" id="author-inp" class="prop-inp" maxlength="128" :disabled="completed">
        </div>

        <div v-if="!completed" class="symmetry-container prop-container">
          These symmetry options determine how the black squares are automatically filled in symetrically.
          180&deg; rotational symmetry is the default and the pattern that most NY Times crosswords follow.
          You can change this setting at will as you write your puzzle, and turn off automatic black square
          addition/deletion by choosing 'None'
          <div class="radio-container">
            <input type="radio" id="rotational" name="symmetry" value="rotational" v-model="symmetry">
            <label for="rotational">Rotational (default)</label>
          </div>
          <div class="radio-container">
            <input type="radio" id="vertical" name="symmetry" value="vertical" v-model="symmetry">
            <label for="vertical">Vertical</label>
          </div>
          <div class="radio-container">
            <input type="radio" id="horizontal" name="symmetry" value="horizontal" v-model="symmetry">
            <label for="horizontal">Horizontal</label>
          </div>
          <div class="radio-container">
            <input type="radio" id="none" name="symmetry" value="none" v-model="symmetry">
            <label for="none">None</label>
          </div>
        </div>

        <div class="complete-container prop-container">
          <button v-if="!completed" id="complete-btn" class="btn green" @click="markComplete">
            Mark as complete
          </button>
          <button v-if="completed" id="complete-btn" class="btn green" @click="editPuzzle">
            Edit
          </button>
        </div>

        <div class="delete-container prop-container">
          <label for="delete-btn">Delete this puzzle (this cannot be undone; export this puzzle's data if you need
            to keep a copy)</label>
          <button id="delete-btn" class="btn danger" title="Delete puzzle">Delete</button>
        </div>

      </div>
    </v-tab>

    <v-tab title="Statistics">
      <div class="properties-container">
        <div class="stat-container">
          <h3>Word Stats</h3>
          <ul class="stats-wc">
            <li><span class="bold">Across:</span> ${ stats.wc.across }</li>
            <li><span class="bold">Down:</span> ${ stats.wc.down }</li>
            <li><span class="bold">Total:</span> ${ stats.wc.across + stats.wc.down }</li>
            <!-- <hr> -->
            <li><span class="bold">Average word length:</span> ${ stats.avg } (inlcudes full rebus entries in across and
              down answers)</li>
          </ul>
        </div>
        <div class="stat-container">
          <h3>Letter Stats</h3>
          <ul class="stats-wc">
            <li><span class="bold">Coverage:</span> ${ stats.coverage } out of 26 letters</li>
            <li><span class="bold">Missing:</span> ${ stats.missing.join(', ') }</li>
          </ul>

          <letter-distribution :height="75" :chart-data="chartData"></letter-distribution>
          (Rebus entries do not contribute to any of these totals.)
        </div>


        <div class="stat-container">
          <h3>Blocks, Circles, Rebused</h3>
          <ul class="stats-wc">
            <li><span class="bold">Blocks (i.e. black squares):</span> ${ stats.blocks }</li>
            <li><span class="bold">Rebus Entries:</span> ${ stats.rebus }</li>
            <li><span class="bold">Circles (i.e. black squares):</span> ${ stats.circles }</li>
          </ul>
        </div>
      </div>
    </v-tab>

    <v-tab title="How to ...">
      <div class="tips">
        <h3>Click Tips:</h3>
        <ul>
          <p>✚ Click <strong>SAVE</strong> button to save your current puzzle.</p>
          <p>✚ Click <strong>"WordNerd"</strong> in top left corner to return to your home page.</p>
          <p>✚ Click <strong>MARK AS COMPLETE</strong> button on the Puzzle Properties tab to
            move the puzzle to your completed puzzle list and prevent further edits (or on a completed puzzle, you can
            choose to reopen the puzzle for editing on the Puzzle Properties tab).</p>
        </ul>

        <h3>Cell Tips:</h3>
        <ul>
          <p>✚ Enter a period in a cell to create a black square.</p>
          <p>✚ Choose the symmetry you would like the black squares to update with automatically, or turn off this
            feature
            under the Puzzle Properties tab.
          </p>
          <p>✚ Use keyboard <strong>ARROWS</strong> to move from cell to cell.</p>
          <p>✚ Press <strong>ENTER</strong> to jump to the next word in the grid, and
            <strong>SHIFT+ENTER</strong> to jump backwards one word.</p>
          <p>✚ Press <strong>SPACEBAR</strong> to change the direction.</p>
        </ul>

        <h3>Grid Tips:</h3>
        <ul>
          <p>✚ Use mouse to click on clue to activate word.</p>
          <p>✚ When editing current clue, <strong>TAB</strong> to return to grid.</p>
          <p>✚ <strong>SHIFT + TAB</strong> to edit clue for current word.</p>
          <p>✚ Select <strong>Puzzle Properties</strong> tab to change Symmetry Options.</p>
        </ul>

        <h3>Rebus:</h3>
        <ul>
          <p>
            ✚ Entering <strong>Command+Enter</strong> on a Mac or <strong>Windows Key + Enter</strong> other PC's
            allow you to type a rebus entry in the active cell.
          </p>
          <p>
            ✚ Click any cell while holding the Meta/Super key (a.k.a. windows key or command key on mac) to enter a
            rebus entry.
          </p>
          <p>
            ✚ Press <strong>Enter</strong> to keep the rebus entry, or click elsewhere on the page to close
            and cancel the rebus input. Hitting <strong>Tab</strong> while entering a rebus will also cancel the
            rebus input.
          </p>
          <p>
            ✚ Grid cells will be highlighted to indicate they are a rebus entry and show the first character of the
            rebus word.
          </p>
          <p>
            ✚ To unmark a cell as a rebus, edit the rebus word back down to 0 or 1 character or by typing over it</p>
        </ul>

        <h3>Circled cells:</h3>
        <ul>
          <p>✚ Typing <strong>Option+Enter</strong> on a Mac or <strong>Alt + Enter</strong> other PC's
            will toggle a circle on the active cell.
          </p>
          <p>✚ Clicking any cell while holding the Option key on a Mac or Alt key on other PCs will also toggle
            a circle on that cell.
          </p>
        </ul>
      </div>
    </v-tab>

    <v-tab title="Export">
      <div class="export-list-container">
        <div class="export-container">
          <h4>Across Lite text format</h4>
          <p>
            If you use the Across Lite solver, you can download the following text files and open them in Across Lite.
          </p>
          <p>
            See the Across List website for
            <a href="https://icrossword.com/publish/" target="_blank" rel="noopener noreferrer">
              how to publish
            </a> your puzzle using their free hosting servive.
          </p>
          <p>
            Across Lite version 1 does not support rebus entries or circled cells. Rebus puzzles can still be
            opened in Across Lite, but will keep only the first character of the rebus entry.
          </p>
          <a id="export-txt-v1" download="across-lite-v1.txt" href="">
            <button id="txt-v1-btn" class="btn save-btn">Download v1</button>
          </a>
          <br>
          <p>
            Across Lite version 2 supports rebus entries:
          </p>
          <a id="export-txt-v2" download="across-lite-v2.txt" href="">
            <button id="txt-v2-btn" class="btn save-btn">Download v2</button>
          </a>
        </div>

        <div id="nyt-app" class="export-container nytimes">
          <h4>New York Times Submission</h4>
          Download a pdf of your puzzle in the
          <a href="https://www.nytimes.com/puzzles/submissions/crossword" target="_blank"
            rel="noopener noreferrer">format</a>
          required to submit to the New York Times (requires an address, which we do not save).
          <form id="export-nytimes-pdf">
            {% csrf_token %}
            <div class="flexrow">
              <div class="inp-label-container">
                <label for="firstname">First name:</label>
                <input type="text" id="firstname">
              </div>
              <div class="inp-label-container">
                <label for="lastname">Last name:</label>
                <input type="text" id="lastname">
              </div>
            </div>
            <div class="inp-label-container">
              <label for="street">Street Adress:</label>
              <input type="text" id="street">
            </div>
            <div class="inp-label-container">
              <label for="city">City:</label>
              <input type="text" id="city">
            </div>
            <div class="flexrow">
              <div class="inp-label-container">
                <label for="state">State:</label>
                <input type="text" id="state" maxlength="2" width="2" placeholder="AA">
              </div>
              <div class="inp-label-container">
                <label for="zip">ZIP Code:</label>
                <input type="text" id="zip" maxlength="5" width="5" placeholder="00000">
              </div>
            </div>
            <div class="inp-label-container">
              <label for="email">Email:</label>
              <input type="email" id="email" size="30">
            </div>
            <button id="nyt-btn" class="btn save-btn" type="submit">Download</button> (this may take a second or two)
          </form>
        </div>
      </div>
      <div class="export-container">
        <h4>
          <a href="https://www.xwordinfo.com/" target="_blank" rel="noopener noreferrer">xwordinfo.com
          </a> JSON format
        </h4>
        <a id="export-json" download="my_exported_puzzle.json" href="">
          <button id="json-btn" class="btn save-btn">Download</button>
        </a>

      </div>
    </v-tab>
  </vue-tabs>

  {% endblock main %}

</div>

<!-- Pass in puzzle json from Django template context -->
{{ puzzle|json_script:"puzzle-data" }}

<script>
  // get json string from django, use it to pass in to Vue app
  let puzzleData = JSON.parse(document.querySelector("#puzzle-data").textContent)
  let totalCellNumber = puzzleData.size.colN * puzzleData.size.rowN
  puzzleData.circles = puzzleData.circles ? puzzleData.circles : Array(totalCellNumber).fill(0)
  const puzzlePK = {{ pk }}
  const completed = {{ completed }}

  const BLACK = '.'


  Vue.component('letter-distribution', {
    extends: VueChartJs.Bar,
    mixins: [VueChartJs.mixins.reactiveProp],
    props: ['chartData'],
    data: function () {
      return {
        chartOptions: {
          tooltips: {
            enabled: true
          },
          scales: {
            yAxes: [{
              ticks: {
                beginAtZero: true
              }
            }]
          }
        }
      }
    },
    mounted() {
      this.renderChart(this.chartData, this.chartOptions)
    }
  })


  /* ================ CLUE Component =================================*/
  Vue.component("x-clue", {
    template: `
      <li class="clue" :class="clueClasses" @click="clicked">
        <slot></slot>
      </li>`,
    props: ['direction', 'gridnums', 'highlighted', 'clueType', 'number', 'crossNumbers'],
    data: function () {
      return {
        test: 1
      };
    },
    computed: {
      isHighlighted() {
        return this.direction === this.clueType && this.gridnums[this.highlighted[0]] == this.number
      },
      isSecondary() {
        return this.direction !== this.clueType && this.crossNumbers[0] == this.number
      },
      clueClasses() {
        return { highlighted: this.isHighlighted, secondary: this.isSecondary }
      }
    },
    watch: {
      isHighlighted: function () {
        this.$nextTick(function () {
          this.scrollClues()
        })
      },
    },
    methods: {
      clicked() {
        this.$emit("clue-clicked", this.number, this.clueType);
      },
      scrollClues() {
        let highlightedClue = document.querySelector('.clue.highlighted')
        let secondaryHlClue = document.querySelector('.clue.secondary')
        if (highlightedClue) {
          highlightedClue.scrollIntoView({ behavior: "smooth", block: "center" })
          secondaryHlClue.scrollIntoView({ behavior: "smooth", block: "center" })
        }
      }
    }
  });



  /* ================ CELL Component =================================*/
  Vue.component("x-cell", {
    template: `
      <div class="cell" :class="cellClasses" :style="cellStyle" @click="clicked">
        <slot name="number"></slot>
        <slot name="entry"></slot>
      </div>`,
    props: ['idx', 'activeCell', 'inputArea', 'grid', 'highlighted', 'colN', 'rowN', 'circles'],
    data: function () {
      return {
        test: 1
      };
    },
    computed: {
      isActive() {
        return this.idx === this.activeCell;
      },
      currentInput() {
        return this.idx === this.inputArea;
      },
      isBlack() {
        return this.grid[this.idx] === BLACK
      },
      isHighlighted() {
        return this.highlighted.includes(this.idx)
      },
      cellClasses() {
        return {
          active: this.isActive,
          black: this.isBlack,
          highlighted: this.isHighlighted,
          rebus: this.grid[this.idx].length > 1,
          circle: this.circles[this.idx] === 1
        }
      },
      cellStyle() {
        let max = Math.max(this.rowN, this.colN)
        return { 'width': `${525 / max}px`, 'height': `${525 / max}px` }
      }
    },
    methods: {
      clicked() {
        this.$emit("cell-clicked", this.idx)
      }
    }
  });



  /* ================ Editor APP =================================*/
  const editor = new Vue({
    el: "#editor-app",
    delimiters: ["${", "}"],
    data: {
      grid: puzzleData.grid, // flat array representation of the grid (left->right, top->bottom)
      clues: puzzleData.clues,
      rowN: puzzleData.size.rowN,
      colN: puzzleData.size.colN,
      title: puzzleData.title,
      description: puzzleData.description,
      author: puzzleData.author,
      symmetry: puzzleData.symmetry, // default: rotational (other values: none, vertical, horizontal )
      completed: completed, // defined line 240
      isVertical: false,
      BLACK: '.',
      across: 'across', // string needed for x-clue component prop
      down: 'down', // string needed for x-clue component prop
      activeCell: 0,
      inputArea: 0,
      lastSaved: '',
      circles: puzzleData.circles
    },

    computed: {
      length() {
        return this.grid.length
      },

      direction() {
        return this.isVertical ? 'down' : 'across'
      },

      gridStyle() {
        return {
          display: 'grid',
          'grid-template-columns': `repeat(${this.colN}, 1fr [col-start])`,
          'grid-auto-rows': '1fr'
        }
      },
      entryFontSize() {
        let max = Math.max(this.rowN, this.colN)
        return `${420 / max}px`
      },

      entryStyle() {
        return { 'font-size': this.entryFontSize }
      },

      numberStyle() {
        let max = Math.max(this.rowN, this.colN)
        return { 'font-size': max > 10 ? '10px' : '14px' }
      },

      clueNumbers() {
        let numbs = { across: [], down: [] }
        this.gridnums.map((number, idx) => {
          if (this.isNumberedCell(idx)) {
            if (this.lookLeft(idx)) {
              numbs.across.push(number)
            }
            if (this.lookUp(idx)) {
              numbs.down.push(number)
            }
          }
        })
        return numbs
      },

      currentClue: {
        get() {
          const direction = this.direction
          const number = this.gridnums[this.highlighted[0]]
          return this.clues[direction][number]
        },
        set(newValue) {
          const direction = this.direction
          const number = this.gridnums[this.highlighted[0]]
          this.clues[direction][number] = newValue.replace(/\n/g, ' ')
        }
      },

      gridnums() {
        let returnArr = []
        let count = 0
        for (let i = 0; i < this.length; i++) {
          if (this.isNumberedCell(i)) {
            count += 1
            returnArr.push(count)
          }
          else {
            returnArr.push(0)
          }
        }
        return returnArr
      },

      highlighted() {
        return this.getInterval(this.activeCell, this.direction)
      },

      answers() {
        let answers = {}
        answers.across = this.clueNumbers.across.map((num) => {
          let idx = this.gridnums.indexOf(num)
          return this.getInterval(idx, "across")
            .map((index) => {
              return this.grid[index]
            })
            .join("")
        })
        answers.down = this.clueNumbers.down.map((num) => {
          let idx = this.gridnums.indexOf(num)
          return this.getInterval(idx, "down")
            .map((index) => {
              return this.grid[index]
            })
            .join("")
        })
        return answers
      },

      stats() {
        let alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'.split('')
        let nonEmptyAns = {
          across: this.answers.across.filter(word => word.length > 0),
          down: this.answers.down.filter(word => word.length > 0)
        }
        let stats = {}
        stats.blocks = this.grid.reduce((acc, curr) => acc += curr === BLACK ? 1 : 0, 0)
        stats.rebus = this.grid.reduce((acc, curr) => acc += curr.length > 1 ? 1 : 0, 0)
        stats.circles = this.circles.reduce((acc, curr) => acc + curr, 0)
        stats.wc = { across: nonEmptyAns.across.length, down: nonEmptyAns.down.length }
        let noAnswers = stats.wc.across === 0 && stats.wc.down === 0
        if (!noAnswers) {
          let avgNum = nonEmptyAns.across.reduce((acc, curr) => acc + curr.length, 0)
            + nonEmptyAns.across.reduce((acc, curr) => acc + curr.length, 0)
          stats.avg = (avgNum / (stats.wc.across + stats.wc.down)).toFixed(2)
        }
        else {
          stats.avg = 'NaN'
        }
        stats.distribution = {}
        alphabet.map(letter => {
          stats.distribution[letter] = this.grid.reduce((acc, curr) => acc += curr === letter ? 1 : 0, 0)
        })
        stats.coverage = alphabet.reduce((acc, curr) => acc += stats.distribution[curr] > 0 ? 1 : 0, 0)
        stats.missing = alphabet.filter(l => stats.distribution[l] === 0)

        return stats
      },

      chartData() {
        return {
          labels: Object.entries(this.stats.distribution), //'ABCDEFGHIJKLMNOPQRSTUVWXYZ'.split(''),
          datasets: [{
            label: 'Letter Distribution',
            data: Object.values(this.stats.distribution),
            backgroundColor: 'rgba(18, 105, 163, 0.2)',
            borderColor: 'rgba(54, 162, 235, 1)',
            hoverBackgroundColor: 'rgba(18, 105, 163, 0.6)',
            borderWidth: 1
          }]
        }
      }
    },

    methods: {
      exportJSON() {
        let grid = this.grid
        let gridnums = this.gridnums
        let size = {
          cols: this.colN,
          rows: this.rowN
        }
        let clues = {
          across: [],
          down: []
        }
        for (let dir of ['across', 'down']) {
          this.clueNumbers[dir].map((number) => {
            let clue = this.clues[dir][number]
            let exportClue = `${number}. ${clue}`
            clues[dir].push(exportClue)
          })
        }
        let title = this.title
        let author = this.author
        let notepad = this.description
        let date = new Date().toJSON()
        let answers = this.answers
        let circles = this.circles.includes(1) ? this.circles : null
        return JSON.stringify({ title, author, notepad, date, grid, gridnums, size, clues, answers, circles })
      },

      getInterval(idx, dir) {
        let returnArr = []
        if (this.grid[idx] === BLACK) {
          return returnArr
        }
        let start = idx
        let stop = idx
        let inc = (dir === 'down') ? this.colN : 1
        if (dir === 'down') {
          while (!this.lookUp(start)) {
            start -= inc
          }
          while (!this.lookDown(stop)) {
            stop += inc
          }
        }
        else {
          while (!this.lookLeft(start)) {
            start -= inc
          }
          while (!this.lookRight(stop)) {
            stop += inc
          }
        }
        for (let i = start; i <= stop; i += inc) {
          returnArr.push(i)
        }
        return returnArr
      },

      getNumberInterval(dir) {
        return this.getInterval(this.activeCell, dir).map(i => this.gridnums[i])
      },

      handleCellClick(idx) {
        if (event.metaKey) {
          this.activeCell = idx
          this.rebusHandler(event, idx, clicked = true)
        }
        else if (event.altKey) {
          this.activeCell = idx
          this.updateCircles(this.activeCell)
        }
        else {
          if (this.activeCell === idx) {
            this.toggleVertical()
          }
          this.activeCell = idx;
        }
      },

      rebusHandler(event, idx, clicked = false) {
        let rebusCell = document.createElement('input', { type: 'text' })
        rebusCell.classList.add('active-rebus')
        rebusCell.id = 'rebus-input'
        let cell = clicked ? event.target.closest('.cell') : document.querySelector('.cell.active')
        cell.appendChild(rebusCell)
        let max = Math.max(this.rowN, this.colN)
        rebusCell.style = `font-size:${this.entryFontSize}; height:${525 / max}px`
        rebusCell.focus()
        rebusCell.value = this.grid[idx]
        rebusCell.style.width = `${rebusCell.value.length + 3}rem`
        rebusCell.setAttribute('onkeypress', "this.style.width = (this.value.length + 3) + 'rem';")
        rebusCell.addEventListener('keydown', (e) => {
          if (e.key.toUpperCase() === 'ENTER') {
            let value = rebusCell.value.toUpperCase()
            this.updateGrid(idx, value)
            rebusCell.remove()
          }
        })
        rebusCell.addEventListener('focusout', (e) => {
          rebusCell.remove()
        })
      },

      handleClueClick(number, clueType) {
        console.log('hi')
        if (clueType !== this.direction) {
          this.toggleVertical()
        }
        const idx = this.gridnums.indexOf(Number(number))
        this.activeCell = idx;
        document.querySelector('#clue-input').focus()
      },

      prepareSaveData() {
        let grid = this.grid
        let clues = this.clues
        let size = { rowN: this.rowN, colN: this.colN }
        let title = this.title
        let description = this.description
        let symmetry = this.symmetry
        let author = this.author
        let gridnums = this.gridnums
        let answers = this.answers
        let circles = this.circles
        let pk = puzzlePK
        return { grid, gridnums, clues, size, title, description, author, answers, symmetry, circles, pk }
      },

      savePuzzle() {
        saveData = this.prepareSaveData(puzzleData)
        return fetch(`/save/`, {
          method: 'POST',
          headers: {
            'Content-type': 'application/json'
          },
          body: JSON.stringify(saveData)
        })
          .then(response => response.json())
          .then(jsonResp => {
            console.log(jsonResp.message)
            let dt = new Date()
            this.lastSaved = { date: dt.toLocaleDateString(), time: dt.toLocaleTimeString() }
          })
      },

      editPuzzle() {
        saveData = this.prepareSaveData(puzzleData)
        return fetch(`/toggle-complete/?pk=${puzzlePK}`
        )
          .then(resp => resp.json())
          .then(jsonData => {
            if (jsonData.redirect === true) {
              window.location.replace(`/edit/${puzzlePK}`)
            }
          })
      },

      markComplete() {
        saveData = this.prepareSaveData(puzzleData)
        return fetch(`/toggle-complete/`, {
          method: 'POST',
          headers: {
            'Content-type': 'application/json'
          },
          body: JSON.stringify(saveData)
        })
          .then(resp => resp.json())
          .then(jsonData => {
            if (jsonData.redirect === true) {
              window.location.replace("/")
            }
          })
      },

      arrayToCoor(idx) {
        return { row: Math.floor(idx / this.colN), col: idx % this.colN }
      },
      coorToArray(row, col) {
        return row * this.colN + col
      },

      computeSymmetry(idx) {
        let row = this.arrayToCoor(idx).row
        let col = this.arrayToCoor(idx).col
        let newRow = this.rowN - row - 1
        let newCol = this.colN - col - 1
        switch (this.symmetry) {
          case "rotational":
            return this.coorToArray(newRow, newCol)
            break
          case "vertical":
            return this.coorToArray(row, newCol)
            break
          case "horizontal":
            return this.coorToArray(newRow, col)
            break
          case "none":
            return this.activeCell
            break
        }
      },

      applySymmetry(idx, value) {
        if (this.grid[idx] === BLACK) {
          this.updateGrid(this.computeSymmetry(idx), value)
        }
      },

      updateGrid(idx, value) {
        // note: splice works when idx < 0, like in Python
        if (value === BLACK && this.circles[idx] === 1) {
          this.updateCircles(idx)
        }
        this.grid.splice(idx, 1, value)
      },

      updateCircles(idx) {
        if (this.grid[idx] !== BLACK) {
          let current = this.circles[idx]
          let newValue = (current + 1) % 2 // toggle between 0 and 1
          this.circles.splice(idx, 1, newValue)
        }
      },

      toggleVertical() {
        this.isVertical = !this.isVertical
      },

      isNumberedCell(idx) {
        if (this.grid[idx] === BLACK) {
          return false
        }
        return this.lookUp(idx) || this.lookLeft(idx)
      },

      lookUp(idx) {
        // return true if idx is in row 1 or is below black square
        return (idx < this.colN) || (this.grid[idx - this.colN] === BLACK)
      },
      lookDown(idx) {
        // return true if idx is in row 1 or is below black square
        return (idx >= this.length - this.colN) || (this.grid[idx + this.colN] === BLACK)
      },
      lookLeft(idx) {
        // return true if idx is in column 1 or to the right of a black square
        return (idx % this.colN === 0) || (this.grid[idx - 1] === BLACK)
      },
      lookRight(idx) {
        // return true if idx is in column 1 or to the right of a black square
        return (idx % this.colN === this.colN - 1) || (this.grid[idx + 1] === BLACK)
      },

      nextCell() {
        if (!this.isVertical) {
          if (this.activeCell < this.length - 1) {
            this.activeCell = this.activeCell + 1
          }
        }
        else {
          this.activeCell += (this.activeCell + this.colN < this.length) ? this.colN : 0
        }
      },

      prevCell() {
        if (!this.isVertical) {
          if (this.activeCell > 0) {
            this.activeCell = this.activeCell - 1
          }
        }
        else {
          this.activeCell -= (this.activeCell - this.colN >= 0) ? this.colN : 0
        }
      },

      jumpWord(dir) {
        // dir should be 1 to jump to next word, or -1 for previous word
        if (this.grid[this.activeCell] === BLACK) {
          while (this.grid[this.activeCell] === BLACK) {
            this.activeCell += dir
          }
        }
        else {
          let numberArray = this.clueNumbers[this.direction]
          let currentNumber = this.gridnums[this.highlighted[0]]
          let currentNumberIdx = numberArray.indexOf(currentNumber)
          let nextNumberIdx = mod(currentNumberIdx + dir, numberArray.length)
          let nextNumber = numberArray[nextNumberIdx]
          this.activeCell = this.gridnums.indexOf(nextNumber)
        }
      },

      keyhandle(event) {
        const key = event.key.toUpperCase()
        let modifierPressed = event.metaKey || event.ctrlKey || event.altKey
        const validEntries = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ.*@#$%&+?'
        const validKeys = ['ARROWUP', 'ARROWDOWN', 'ARROWLEFT', 'ARROWRIGHT', 'BACKSPACE', 'DELETE', 'ENTER', 'HOME', 'END', ' ']
        if (validEntries.includes(key) && !modifierPressed && !this.completed) {
          if (this.grid[this.activeCell] === BLACK) {
            let symmetricEntry = key === BLACK ? BLACK : ''
            this.applySymmetry(this.activeCell, symmetricEntry)
            this.updateGrid(this.activeCell, key)
          }
          else {
            this.updateGrid(this.activeCell, key)
            this.applySymmetry(this.activeCell, BLACK)
          }
          this.nextCell()
        }
        else if (validKeys.includes(key)) {
          event.preventDefault()
          this.nonAlphaKeys(key)
        }
      },

      nonAlphaKeys(key) {
        if (key === 'DELETE') {
          if (this.grid[this.activeCell] === BLACK) {
            this.applySymmetry(this.activeCell, '')
          }
          this.updateGrid(this.activeCell, '')
        }
        else if (key === 'BACKSPACE') {
          if (this.grid[this.activeCell] === '') {
            this.prevCell()
            if (this.grid[this.activeCell] === BLACK) {
              this.applySymmetry(this.activeCell, '')
            }
            this.updateGrid(this.activeCell, '')
          }
          else {
            if (this.grid[this.activeCell] === BLACK) {
              this.applySymmetry(this.activeCell, '')
            }
            this.updateGrid(this.activeCell, '')
          }
        }
        else if (key === 'ENTER') {
          if (event.metaKey) {
            this.rebusHandler(event, this.activeCell)
          }
          else if (event.altKey) {
            this.updateCircles(this.activeCell)
          }
          else if (event.shiftKey) {
            this.jumpWord(-1)
          }
          else {
            this.jumpWord(1)
          }
        }
        else if (key === ' ') {
          this.toggleVertical()
        }
        else if (key === "ARROWRIGHT") {
          if (this.isVertical) {
            this.toggleVertical()
          }
          else {
            this.nextCell()
          }
        }
        else if (key === "ARROWLEFT") {
          if (this.isVertical) {
            this.toggleVertical()
          }
          else {
            this.prevCell()
          }
        }
        else if (key === "ARROWDOWN") {
          if (!this.isVertical) {
            this.toggleVertical()
          }
          else {
            this.nextCell()
          }
        }
        else if (key === "ARROWUP") {
          if (!this.isVertical) {
            this.toggleVertical()
          }
          else {
            this.prevCell()
          }
        }
        else if (key === "HOME") {
          let coors = this.arrayToCoor(this.activeCell)
          if (!this.isVertical) {
            this.activeCell = this.coorToArray(coors.row, 0)
          }
          else {
            this.activeCell = this.coorToArray(0, coors.col)
          }
        }
        else if (key === "END") {
          let coors = this.arrayToCoor(this.activeCell)
          if (!this.isVertical) {
            this.activeCell = this.coorToArray(coors.row, this.colN - 1)
          }
          else {
            this.activeCell = this.coorToArray(this.rowN - 1, coors.col)
          }
        }
      }

    },

    created: function () {
      window.addEventListener('keydown', (event) => {
        let ignoreInputs = document.querySelectorAll('input')
        if (event.target.nodeName !== 'INPUT' && event.target.nodeName !== 'TEXTAREA') {
          this.keyhandle(event)
        }
      })
    }
  });
  // End Vue App

  // Non negative modulus function
  function mod(n, m) {
    return ((n % m) + m) % m;
  }


  const deleteButton = document.querySelector('#delete-btn')
  deleteButton.addEventListener('click', deleteEvent)
  function deleteEvent(event) {
    const result = confirm('Do you want to permanently delete this puzzle?')
    if (result) {
      return fetch(`/delete/${puzzlePK}/`, { method: 'DELETE' })
        .then((resp) => {
          return resp.json()
        })
        .then(jsonResp => {
          if (jsonResp.status === 'ok') {
            window.location.href = '/'
          }
          else {
            deleteButton.insertAdjacentHTML('afterend', `<div class="error">${jsonResp.message}</div>`)
          }
        })
    }
  }


  // === Export Handlers ===
  document.querySelector('#json-btn').addEventListener('click', (event) => {
    const jsn = editor.exportJSON()
    const data = new File([jsn], 'my_exported_puzzle.json', { type: 'application/json' })
    let url = window.URL.createObjectURL(data)
    let anchor = document.querySelector('#export-json')
    anchor.href = url
    editor.savePuzzle()
  })

  document.querySelector('#txt-v1-btn').addEventListener('click', (event) => {
    const txt = exportTXTv1()
    const data = new File([txt], 'across-lite-v1.txt', { type: 'text/plain' })
    let url = window.URL.createObjectURL(data)
    let anchor = document.querySelector('#export-txt-v1')
    anchor.href = url
    editor.savePuzzle()
  })

  document.querySelector('#txt-v2-btn').addEventListener('click', (event) => {
    const txt = exportTXTv2()
    const data = new File([txt], 'across-lite-v2.txt', { type: 'text/plain' })
    let url = window.URL.createObjectURL(data)
    let anchor = document.querySelector('#export-txt-v2')
    anchor.href = url
    editor.savePuzzle()
  })


  document.querySelector('#export-nytimes-pdf').addEventListener('submit', (event) => {
    event.preventDefault()
    let csrftoken = Cookies.get('csrftoken')
    let nytButton = document.querySelector('#nyt-btn')
    nytButton.textContent = 'Loading...'
    let addressInputs = document.querySelectorAll('#export-nytimes-pdf input')
    let formData = {}
    for (let inp of addressInputs) {
      formData[inp.id] = inp.value
    }
    return editor.savePuzzle()
      .then(r => {
        return fetch(`/export/${puzzlePK}/`, {
          method: 'POST',
          headers: {
            "X-CSRFToken": csrftoken,
            'Content-Type': 'application/json',
          },
          body: JSON.stringify(formData)
        })
          .then(resp => {
            nytButton.textContent = "Download"
            return resp.blob()
          })
      })
      .then(blob => {
        let url = window.URL.createObjectURL(blob)
        let a = document.createElement('a')
        a.href = url
        a.download = `${editor.title}_nyt_submit_format.pdf`
        document.body.appendChild(a)
        a.click()
        a.remove()
      })
  })

  function exportTXTv1() {
    let acrossString = ''
    for (let number of editor.clueNumbers.across) {
      acrossString += editor.clues.across[number] + '\n'
    }
    acrossString = acrossString.trimEnd()
    let downString = ''
    for (let number of editor.clueNumbers.down) {
      downString += editor.clues.down[number] + '\n'
    }
    downString = downString.trimEnd()
    let gridString = ''
    for (let i = 0; i < editor.rowN; i++) {
      let row = ''
      for (let j = 0; j < editor.colN; j++) {
        row += editor.grid[i * editor.colN + j][0]
      }
      gridString += row + '\n'
    }
    gridString = gridString.trimEnd()
    let returnString = `<ACROSS PUZZLE>
<TITLE>
${editor.title ? editor.title : ''}
<AUTHOR>
${editor.author ? editor.author : ''}
<COPYRIGHT>

<SIZE>
${editor.colN}x${editor.rowN}
<GRID>
${gridString}
<ACROSS>
${acrossString}
<DOWN>
${downString}
<NOTEPAD>${editor.description ? editor.description : ''}
`
    return returnString
  }

  /*
  * This format uses footnote style references between
  * the <grid> and <rebus> sections to indicate where
  * rebus entries belong.  Because the grid only holds slots for
  * single chars, and we're using digits as the placeholder,
  * this will only make sense for up to 10 _unique_ rebus entries.
  * The other option is to add some special characters as placeholders
  */
  function exportTXTv2() {
    let rebusList = []
    let grid = editor.grid
    grid.map((entry, i) => {
      if (entry.length > 1) {
        rebusList.push(entry)
      }
    })
    let rebusUniqueList = []
    for (let rebus of rebusList) {
      if (!rebusUniqueList.includes(rebus)) {
        rebusUniqueList.push(rebus)
      }
    }

    let markers = ''
    rebusUniqueList.map((rebus, i) => {
      markers += `${i}:${rebus}:${rebus[0]}\n`
    })
    markers.trimEnd()

    let marked = editor.circles.includes(1) ? '\nMARK;' : ''
    let rebusSection = `<REBUS>${marked}\n${markers}`

    let acrossString = ''
    for (let number of editor.clueNumbers.across) {
      acrossString += editor.clues.across[String(number)] + '\n'
    }
    acrossString = acrossString.trimEnd()
    let downString = ''
    for (let number of editor.clueNumbers.down) {
      downString += editor.clues.down[String(number)] + '\n'
    }
    downString = downString.trimEnd()

    let gridString = ''
    for (let i = 0; i < editor.rowN; i++) {
      let row = ''
      for (let j = 0; j < editor.colN; j++) {
        let idx = i * editor.colN + j
        let entry = grid[idx]
        if (entry.length === 0) {
          row += 'X'
        }
        else if (entry.length > 1) {
          row += rebusUniqueList.indexOf(entry)
        }
        else if (editor.circles[idx] === 1) {
          row += entry.toLowerCase()
        }
        else {
          row += entry
        }
      }
      gridString += row + '\n'
    }
    gridString = gridString.trimEnd()

    return `<ACROSS PUZZLE V2>
<TITLE>
  ${editor.title ? editor.title : ''}
<AUTHOR>
${editor.author ? editor.author : ''}
<COPYRIGHT>

<SIZE>
${editor.colN}x${editor.rowN}
<GRID>
${gridString}
${rebusList.length > 0 || marked ? rebusSection : ''}<ACROSS>
${acrossString}
<DOWN>
${downString}
<NOTEPAD>${editor.description ? '\n' + editor.description : ''}
`
  }

</script>

{% endblock content %}